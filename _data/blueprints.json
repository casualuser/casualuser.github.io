[
  {
    "version": 1,
    "id": "business-microservices",
    "name": "Business: Microservices Gateway",
    "segment": "business",
    "summary": "A modern architecture for scaling businesses, using an API Gateway to\nunify multiple distinct microservices (likely containerized).\n",
    "description": "For established businesses with multiple product lines or domains, a monolith\ncan become a bottleneck. This architecture introduces a strong API Gateway\npattern to route traffic to specialized services.\n\n**Core Components:**\n*   **API Gateway**: A high-performance entry point (Kong, Tyk, or Cloud Native LB) that handles auth, rate limiting, and routing.\n*   **Microservices**: Distinct services (e.g., Billing, Users, Catalog) written in the best tool for the job.\n*   **Container Runtime**: Services run in containers (Docker/K8s) for isolation.\n*   **Event Bus**: Asynchronous communication happens via RabbitMQ, Kafka, or Cloud Pub/Sub.\n\n**Why this stack?**\nIt allows teams to work independently on different \"Bounded Contexts\" while presenting a unified API surface to clients.\n",
    "stack": {
      "segment": "business",
      "deployment": "containers",
      "gateway": "api-gateway",
      "orchestration": "kubernetes-ecs",
      "communication": "rest-grpc"
    },
    "components": [
      {
        "id": "user",
        "name": "Client Apps",
        "type": "actor"
      },
      {
        "id": "gateway",
        "name": "API Gateway",
        "type": "gateway",
        "depends_on": [
          "svc_a",
          "svc_b",
          "svc_c"
        ],
        "ports": [
          "REST/GraphQL"
        ]
      },
      {
        "id": "svc_a",
        "name": "Identity Service",
        "type": "service",
        "depends_on": [
          "db_a",
          "bus"
        ]
      },
      {
        "id": "svc_b",
        "name": "Billing Service",
        "type": "service",
        "depends_on": [
          "db_b",
          "bus"
        ]
      },
      {
        "id": "svc_c",
        "name": "Product Service",
        "type": "service",
        "depends_on": [
          "db_c"
        ]
      },
      {
        "id": "bus",
        "name": "Event Bus",
        "type": "message-broker",
        "notes": "Async Events"
      },
      {
        "id": "db_a",
        "name": "Identity DB",
        "type": "database"
      },
      {
        "id": "db_b",
        "name": "Billing DB",
        "type": "database"
      },
      {
        "id": "db_c",
        "name": "Product DB",
        "type": "database"
      }
    ],
    "groups": [
      {
        "id": "cluster",
        "members": [
          "gateway",
          "svc_a",
          "svc_b",
          "svc_c"
        ]
      },
      {
        "id": "data",
        "members": [
          "db_a",
          "db_b",
          "db_c",
          "bus"
        ]
      }
    ],
    "tags": [
      "business",
      "microservices",
      "gateway",
      "containers",
      "distributed"
    ]
  },
  {
    "version": 1,
    "id": "data-analytics-modern",
    "name": "Modern Data Analytics Pipeline",
    "segment": "enterprise",
    "summary": "A robust ELT (Extract, Load, Transform) pipeline designed for scalability and modularity.\nLeverages the \"Modern Data Stack\" ecosystem.\n",
    "description": "This architecture separates the concerns of data ingestion, transformation, and storage,\nallowing data teams to iterate quickly.\n\n**Core Components:**\n*   **Orchestration (Airflow/Prefect)**: Manages the schedule and dependencies of data workflows.\n*   **Transformation (dbt)**: \"Data Build Tool\" runs SQL transformations inside the warehouse, applying engineering practices (testing, version control) to data/analytics code.\n*   **Cloud Data Warehouse (Snowflake/BigQuery)**: Serverless, infinite-scale storage that separates compute from storage.\n*   **BI Layer (Looker/Superset)**: Visual exploration and dashboarding for business stakeholders.\n\n**Why this stack?**\nThe \"ELT\" pattern (loading raw data first, then transforming it) is more resilient than traditional ETL and preserves the raw source of truth.\n",
    "stack": {
      "segment": "enterprise",
      "orchestration": "airflow",
      "transformation": "dbt",
      "warehouse": "snowflake",
      "bi": "looker"
    },
    "components": [
      {
        "id": "sources",
        "name": "Data Sources",
        "type": "external",
        "notes": "APIs, DBs, Events"
      },
      {
        "id": "airflow",
        "name": "Airflow (Orchestrator)",
        "type": "orchestrator",
        "depends_on": [
          "sources"
        ]
      },
      {
        "id": "warehouse",
        "name": "Snowflake (Warehouse)",
        "type": "database",
        "depends_on": [
          "airflow"
        ],
        "notes": "Raw & Bronze Layers"
      },
      {
        "id": "dbt",
        "name": "dbt (Transformation)",
        "type": "service",
        "depends_on": [
          "warehouse"
        ],
        "notes": "SQL Modeling"
      },
      {
        "id": "bi",
        "name": "Looker / Superset",
        "type": "dashboard",
        "depends_on": [
          "warehouse"
        ],
        "notes": "Business Intelligence"
      }
    ],
    "groups": [
      {
        "id": "ingestion",
        "members": [
          "sources",
          "airflow"
        ]
      },
      {
        "id": "processing",
        "members": [
          "warehouse",
          "dbt"
        ]
      },
      {
        "id": "consumption",
        "members": [
          "bi"
        ]
      }
    ],
    "tags": [
      "data-engineering",
      "elt",
      "dbt",
      "snowflake",
      "airflow"
    ]
  },
  {
    "version": 1,
    "id": "enterprise-platform",
    "name": "Enterprise: Cloud Native Platform",
    "segment": "enterprise",
    "summary": "A comprehensive Kubernetes-based internal developer platform with\nService Mesh, GitOps, Compliance Monitoring, and Observability.\n",
    "description": "At the enterprise level, the focus shifts from \"running an app\" to \"running a platform.\"\nThis architecture provides a standardized \"Paved Road\" for hundreds of developers.\n\n**Core Components:**\n*   **Kubernetes (K8s) Cluster**: The universal substrate for compute.\n*   **GitOps (ArgoCD)**: Deployment state is managed strictly via Git repositories, ensuring auditability and rollback.\n*   **Service Mesh (Istio/Linkerd)**: Automatically handles mTLS encryption, traffic splitting, and deep telemetry without code changes.\n*   **Policy Engine (OPA)**: Enforces corporate compliance (e.g., \"No public info in logs\", \"Required labels\") at the admission level.\n*   **Observability Stack**: Prometheus, Grafana, and ELK/Loki stack for full-system visibility.\n\n**Compliance & Security:**\nAll traffic is encrypted in transit and at rest. Access is controlled via OIDC/SSO integration.\n",
    "stack": {
      "segment": "enterprise",
      "orchestration": "kubernetes",
      "gitops": "argocd",
      "mesh": "istio",
      "observability": "full-stack"
    },
    "components": [
      {
        "id": "dev",
        "name": "Developer",
        "type": "actor"
      },
      {
        "id": "git",
        "name": "Git Repository",
        "type": "source-control",
        "depends_on": [
          "dev"
        ]
      },
      {
        "id": "argocd",
        "name": "ArgoCD Controller",
        "type": "gitops",
        "depends_on": [
          "git"
        ],
        "notes": "Reconciles State"
      },
      {
        "id": "k8s",
        "name": "K8s API",
        "type": "orchestrator",
        "depends_on": [
          "opa"
        ]
      },
      {
        "id": "opa",
        "name": "Policy (OPA/Kyverno)",
        "type": "compliance",
        "notes": "Admission Control"
      },
      {
        "id": "istio",
        "name": "Service Mesh Control",
        "type": "network",
        "notes": "mTLS & Traffic"
      },
      {
        "id": "workload",
        "name": "Business Apps",
        "type": "container",
        "depends_on": [
          "istio"
        ]
      },
      {
        "id": "obs",
        "name": "Observability",
        "type": "tools",
        "depends_on": [
          "workload",
          "k8s"
        ],
        "notes": "Metrics/Logs/Traces"
      }
    ],
    "groups": [
      {
        "id": "platform-layer",
        "members": [
          "argocd",
          "k8s",
          "opa",
          "istio",
          "obs"
        ]
      },
      {
        "id": "app-layer",
        "members": [
          "workload"
        ]
      }
    ],
    "tags": [
      "enterprise",
      "kubernetes",
      "gitops",
      "istio",
      "platform-engineering"
    ]
  },
  {
    "version": 1,
    "id": "frontend-jamstack-pro",
    "name": "Professional Jamstack Frontend",
    "segment": "startup",
    "summary": "A high-performance, edge-delivered frontend stack optimizing for\nCore Web Vitals and developer experience.\n",
    "description": "The \"Jamstack\" (JavaScript, APIs, Markup) philosophy has evolved into dynamic, edge-cached applications.\nThis stack provides the fastest possible \"Time to First Byte\" globally.\n\n**Core Components:**\n*   **Next.js (Framework)**: React framework handling hybrid rendering (SSR/SSG) and routing.\n*   **Vercel/Cloudflare (Edge)**: Global CDN that caches not just assets but also dynamic serverless functional responses.\n*   **Headless CMS (Sanity/Contentful)**: Decoupled content management allowing marketers to edit content without touching code.\n*   **Headless Commerce/API**: Backend logic connected via typed APIs.\n\n**Why this stack?**\nDecoupling the frontend from the backend (Headless) allows each layer to scale independently and lets frontend teams ship daily without backend bottlenecks.\n",
    "stack": {
      "segment": "startup",
      "framework": "nextjs",
      "platform": "vercel",
      "cms": "headless",
      "rendering": "hybrid"
    },
    "components": [
      {
        "id": "user",
        "name": "User Device",
        "type": "actor"
      },
      {
        "id": "edge",
        "name": "Edge Network (CDN)",
        "type": "gateway",
        "depends_on": [
          "nextjs"
        ],
        "notes": "Cache & Routing"
      },
      {
        "id": "nextjs",
        "name": "Next.js App",
        "type": "application",
        "depends_on": [
          "cms",
          "api"
        ],
        "notes": "ISR / SSR / SSG"
      },
      {
        "id": "cms",
        "name": "Headless CMS",
        "type": "saas",
        "notes": "Content API"
      },
      {
        "id": "api",
        "name": "Backend API",
        "type": "service",
        "notes": "Business Logic"
      }
    ],
    "groups": [
      {
        "id": "frontend",
        "members": [
          "edge",
          "nextjs"
        ]
      },
      {
        "id": "backend",
        "members": [
          "cms",
          "api"
        ]
      }
    ],
    "tags": [
      "jamstack",
      "nextjs",
      "react",
      "headless",
      "performance"
    ]
  },
  {
    "id": "lamp-stack",
    "name": "LAMP Stack (Classic)",
    "segment": "stack",
    "summary": "Linux, Apache, MySQL, PHP. The original web stack.",
    "description": "The LAMP stack is a classic, battle-tested architecture for hosting dynamic websites and content management systems like WordPress, Drupal, or custom PHP applications.\n\nIt relies on Linux as the OS, Apache as the web server, MySQL (or MariaDB) for relational data, and PHP as the scripting language.\n",
    "tags": [
      "lamp",
      "php",
      "apache",
      "mysql",
      "linux"
    ],
    "stack": {
      "app": "PHP / WordPress",
      "web": "Apache",
      "db": "MySQL / MariaDB",
      "os": "Linux"
    },
    "components": [
      {
        "id": "users",
        "type": "actor",
        "name": "Web Visitors",
        "notes": "Public Traffic"
      },
      {
        "id": "vm",
        "type": "compute",
        "name": "Virtual Machine",
        "notes": "Linux (Ubuntu/Debian)"
      },
      {
        "id": "apache",
        "type": "network",
        "name": "Apache HTTPD",
        "notes": "Web Server + ModPHP"
      },
      {
        "id": "app",
        "type": "container",
        "name": "PHP Application",
        "notes": "WordPress / Custom"
      },
      {
        "id": "db",
        "type": "database",
        "name": "MySQL / MariaDB",
        "notes": "Relational Database"
      },
      {
        "id": "fs",
        "type": "storage",
        "name": "Local Filesystem",
        "notes": "/var/www/html"
      },
      {
        "id": "users",
        "depends_on": "apache"
      },
      {
        "id": "apache",
        "depends_on": "app"
      },
      {
        "id": "app",
        "depends_on": [
          "db",
          "fs"
        ]
      }
    ],
    "groups": [
      {
        "id": "server",
        "name": "Web Server (Single Node)",
        "members": [
          "vm",
          "apache",
          "app",
          "db",
          "fs"
        ]
      }
    ]
  },
  {
    "id": "lemp-stack",
    "name": "LEMP Stack (High Performance)",
    "segment": "stack",
    "summary": "Linux, Nginx, MySQL, PHP. High concurrency alternative to LAMP.",
    "description": "The LEMP stack swaps Apache for Nginx, providing better performance under high concurrency and lower memory usage for static asset serving.\n\nPHP is executed via PHP-FPM (FastCGI Process Manager), which allows for better process management and separation of concerns compared to Apache's mod_php.\n",
    "tags": [
      "lemp",
      "php",
      "nginx",
      "mysql",
      "linux"
    ],
    "stack": {
      "app": "PHP-FPM",
      "web": "Nginx",
      "db": "MySQL / MariaDB",
      "os": "Linux"
    },
    "components": [
      {
        "id": "users",
        "type": "actor",
        "name": "Web Visitors",
        "notes": "Public Traffic"
      },
      {
        "id": "vm",
        "type": "compute",
        "name": "Virtual Machine",
        "notes": "Linux (Ubuntu/Debian)"
      },
      {
        "id": "nginx",
        "type": "network",
        "name": "Nginx",
        "notes": "Reverse Proxy & Static"
      },
      {
        "id": "fpm",
        "type": "container",
        "name": "PHP-FPM",
        "notes": "FastCGI Process Manager"
      },
      {
        "id": "app",
        "type": "container",
        "name": "Application Code",
        "notes": "Laravel / Symfony"
      },
      {
        "id": "db",
        "type": "database",
        "name": "MySQL / MariaDB",
        "notes": "Relational Database"
      },
      {
        "id": "redis",
        "type": "database",
        "name": "Redis",
        "notes": "Object Cache (Optional)"
      },
      {
        "id": "users",
        "depends_on": "nginx"
      },
      {
        "id": "nginx",
        "depends_on": "fpm"
      },
      {
        "id": "fpm",
        "depends_on": "app"
      },
      {
        "id": "app",
        "depends_on": [
          "db",
          "redis"
        ]
      }
    ],
    "groups": [
      {
        "id": "server",
        "name": "Web Server (Single Node)",
        "members": [
          "vm",
          "nginx",
          "fpm",
          "app",
          "db",
          "redis"
        ]
      }
    ]
  },
  {
    "id": "mern-stack",
    "name": "MERN Stack (Fullstack JS)",
    "segment": "stack",
    "summary": "MongoDB, Express, React, Node.js. The JavaScript monolith.",
    "description": "The MERN stack is a pure JavaScript stack for building modern single-page applications (SPAs).\n\nIt features React for the frontend, Node.js/Express for the backend API, and MongoDB for JSON-native document storage.\n",
    "tags": [
      "mern",
      "javascript",
      "react",
      "nodejs",
      "mongodb"
    ],
    "stack": {
      "frontend": "React",
      "backend": "Node.js (Express)",
      "db": "MongoDB",
      "host": "VM / PaaS"
    },
    "components": [
      {
        "id": "users",
        "type": "actor",
        "name": "Users",
        "notes": "Browser / Mobile"
      },
      {
        "id": "cdn",
        "type": "network",
        "name": "CDN / Storage",
        "notes": "Serves React Bundle"
      },
      {
        "id": "spa",
        "type": "container",
        "name": "React SPA",
        "notes": "Client-Side App"
      },
      {
        "id": "api",
        "type": "compute",
        "name": "Express API",
        "notes": "Node.js Backend"
      },
      {
        "id": "db",
        "type": "database",
        "name": "MongoDB",
        "notes": "Document Store"
      },
      {
        "id": "users",
        "depends_on": [
          "cdn",
          "spa"
        ]
      },
      {
        "id": "spa",
        "depends_on": "api"
      },
      {
        "id": "api",
        "depends_on": "db"
      }
    ],
    "groups": [
      {
        "id": "cloud",
        "name": "Deployment Infrastructure",
        "members": [
          "cdn",
          "api",
          "db"
        ]
      }
    ]
  },
  {
    "id": "pern-stack",
    "name": "PERN Stack (Postgres)",
    "segment": "stack",
    "summary": "Postgres, Express, React, Node.js. SQL-backed JS stack.",
    "description": "The PERN stack is similar to MERN but chooses PostgreSQL for data integrity and relational mapping.\n\nIt is ideal for applications that require complex queries, transactions, and structured data schemas.\n",
    "tags": [
      "pern",
      "javascript",
      "react",
      "nodejs",
      "postgres"
    ],
    "stack": {
      "frontend": "React",
      "backend": "Node.js (Express)",
      "db": "PostgreSQL",
      "host": "VM / PaaS"
    },
    "components": [
      {
        "id": "users",
        "type": "actor",
        "name": "Users",
        "notes": "Browser / Mobile"
      },
      {
        "id": "cdn",
        "type": "network",
        "name": "CDN / Storage",
        "notes": "Serves React Bundle"
      },
      {
        "id": "spa",
        "type": "container",
        "name": "React SPA",
        "notes": "Client-Side App"
      },
      {
        "id": "api",
        "type": "compute",
        "name": "Express API",
        "notes": "Node.js Backend"
      },
      {
        "id": "db",
        "type": "database",
        "name": "PostgreSQL",
        "notes": "Relational Database"
      },
      {
        "id": "users",
        "depends_on": [
          "cdn",
          "spa"
        ]
      },
      {
        "id": "spa",
        "depends_on": "api"
      },
      {
        "id": "api",
        "depends_on": "db"
      }
    ],
    "groups": [
      {
        "id": "cloud",
        "name": "Deployment Infrastructure",
        "members": [
          "cdn",
          "api",
          "db"
        ]
      }
    ]
  },
  {
    "version": 1,
    "id": "smb-vm-spa",
    "name": "SMB: SPA + Backend API",
    "segment": "smb",
    "summary": "A standard decoupled architecture for Small-to-Medium Businesses.\nServes a compiled Single Page Application (React/Vue) alongside a robust\nAPI backend on standard virtual infrastructure.\n",
    "description": "As businesses grow, separating the frontend and backend becomes crucial for\nindependent scaling and team specialization. This pattern serves a compiled\napplication (SPA) alongside a REST/GraphQL API.\n\n**Core Components:**\n*   **Frontend**: A React, Vue, or Angular application built into static files, served directly by Nginx.\n*   **Backend API**: A generic backend (Node, Python, Go) exposing JSON APIs.\n*   **Nginx Gatekeeper**: Routes traffic based on path (`/api/*` vs `/*`), manages CORS, and handles SSL.\n*   **Database**: Managed database instance (RDS, Cloud SQL, etc.) for reliability.\n\n**Deployment:**\nUsually deployed via CI/CD pipelines that build artifacts (JS bundles, binaries) and copy them to the VM or update the running process.\n",
    "stack": {
      "segment": "smb",
      "deployment": "vm-decoupled",
      "frontend": "react-vue-angular",
      "backend": "node-python-go",
      "web_server": "nginx",
      "database": "postgres-mysql"
    },
    "components": [
      {
        "id": "user",
        "name": "Browser Client",
        "type": "actor"
      },
      {
        "id": "nginx",
        "name": "Nginx Gateway",
        "type": "gateway",
        "depends_on": [
          "frontend",
          "backend"
        ],
        "notes": "Route: /api -> Backend, /* -> Frontend"
      },
      {
        "id": "frontend",
        "name": "Static Assets (SPA)",
        "type": "storage",
        "notes": "HTML/JS/CSS"
      },
      {
        "id": "backend",
        "name": "Backend Server",
        "type": "service",
        "depends_on": [
          "db"
        ],
        "notes": "API Logic"
      },
      {
        "id": "db",
        "name": "Managed Database",
        "type": "database",
        "notes": "High Availability"
      }
    ],
    "groups": [
      {
        "id": "server",
        "members": [
          "nginx",
          "frontend",
          "backend"
        ]
      }
    ],
    "tags": [
      "smb",
      "react",
      "vue",
      "angular",
      "nginx",
      "spa"
    ]
  },
  {
    "version": 1,
    "id": "startup-node-supabase",
    "name": "Startup: Node.js + Supabase",
    "segment": "startup",
    "summary": "A rapid-development stack using a simple Node.js API (Express/NestJS) for logic\nand Supabase for the heavy lifting of Auth, DB, and Realtime.\n",
    "description": "This architecture leverages the \"Backend-as-a-Service\" model to reduce\ninfrastructure overhead. The Node.js service is lightweight, handling only\ncustom business logic that doesn't fit into database policies.\n\n**Core Components:**\n*   **Supabase**: Provides a fully managed PostgreSQL database, Authentication system, and Auto-generated APIs.\n*   **Node.js Service**: A simplified backend running on a VM or small container, handling webhooks, integrations, or complex non-SQL logic.\n*   **Nginx**: Secures the Node.js API and serves the frontend assets if not CDN-hosted.\n\n**Why this stack?**\nSupabase handles 80% of standard SaaS features (User management, Row Level Security) out of the box, allowing founders to focus on product differentiation.\n",
    "stack": {
      "segment": "startup",
      "deployment": "hybrid-baas",
      "language": "nodejs",
      "database": "supabase",
      "web_server": "nginx"
    },
    "components": [
      {
        "id": "user",
        "name": "User",
        "type": "actor"
      },
      {
        "id": "nginx",
        "name": "Nginx",
        "type": "gateway",
        "depends_on": [
          "api"
        ]
      },
      {
        "id": "api",
        "name": "Node.js API",
        "type": "service",
        "depends_on": [
          "supabase"
        ],
        "notes": "Custom Logic"
      },
      {
        "id": "supabase",
        "name": "Supabase Platform",
        "type": "baas",
        "notes": "Auth, DB, Realtime"
      }
    ],
    "groups": [
      {
        "id": "infra",
        "members": [
          "nginx",
          "api"
        ]
      }
    ],
    "tags": [
      "startup",
      "nodejs",
      "supabase",
      "postgres",
      "baas"
    ]
  },
  {
    "version": 1,
    "id": "startup-vm-python",
    "name": "Startup: Python Monolith on VM",
    "segment": "startup",
    "summary": "A cost-effective, simple deployment for early-stage startups. Runs a Python\nweb application (Django/FastAPI) behind Nginx on a single Virtual Machine.\n",
    "description": "This architecture is optimized for speed of iteration and simplicity. It avoids\ncomplex orchestration frameworks in favor of a reliable, well-understood\n\"Monolith on a Box\" pattern.\n\n**Core Components:**\n*   **Virtual Machine**: A single compute instance (AWS EC2, Google Compute, Azure VM, or DigitalOcean Droplet) hosts the entire stack.\n*   **Nginx**: Acts as the reverse proxy, handling SSL termination, static file serving, and forwarding traffic to the application server.\n*   **Application Server**: Runs the Python code (e.g., Gunicorn for Django/FastAPI).\n*   **Database**: A local or managed PostgreSQL instance provides relational data storage.\n*   **Redis**: Used for caching and background tasks (e.g., Celery) to keep the main thread responsive.\n\n**Why this stack?**\nFor a new project, \"boring\" technology is a competitive advantage. This stack\nscales vertically for a long time before needing horizontal breakdown.\n",
    "stack": {
      "segment": "startup",
      "deployment": "vm-monolith",
      "language": "python",
      "web_server": "nginx",
      "database": "postgres",
      "cache": "redis"
    },
    "components": [
      {
        "id": "user",
        "name": "User / Client",
        "type": "actor"
      },
      {
        "id": "host",
        "name": "Virtual Machine (Linux)",
        "type": "compute",
        "notes": "Ubuntu / Debian"
      },
      {
        "id": "nginx",
        "name": "Nginx",
        "type": "gateway",
        "depends_on": [
          "app"
        ],
        "notes": "Reverse Proxy & SSL"
      },
      {
        "id": "app",
        "name": "Python App (Gunicorn)",
        "type": "service",
        "depends_on": [
          "db",
          "redis"
        ],
        "ports": [
          "8000"
        ]
      },
      {
        "id": "db",
        "name": "PostgreSQL",
        "type": "database",
        "notes": "Local or Managed"
      },
      {
        "id": "redis",
        "name": "Redis",
        "type": "cache",
        "notes": "Cache & Broker"
      }
    ],
    "groups": [
      {
        "id": "vm-layer",
        "members": [
          "nginx",
          "app",
          "db",
          "redis"
        ],
        "parent": "host"
      }
    ],
    "tags": [
      "startup",
      "python",
      "django",
      "fastapi",
      "nginx",
      "vm"
    ]
  }
]